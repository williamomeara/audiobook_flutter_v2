/// Demand level representing urgency of synthesis needs.
///
/// Ordered from lowest urgency (coast) to highest (critical).
enum DemandLevel {
  /// Way ahead of playback (>45s buffer). Minimize work, save battery.
  coast,

  /// Comfortable buffer (30-45s). Maintain steady pace.
  cruise,

  /// Buffer getting thin (15-30s). Speed up synthesis.
  accelerate,

  /// Dangerously close (<15s). Maximum effort, ignore cooldowns.
  emergency,

  /// About to run out (<5s). Panic mode - boost priority, max concurrency.
  critical,
}

/// Signal indicating current synthesis demand based on buffer status.
///
/// Generated by [BufferGauge] and consumed by [ConcurrencyGovernor].
class DemandSignal {
  /// The urgency level based on buffer ahead of playback.
  final DemandLevel level;

  /// Actual buffer in seconds (playback-rate adjusted).
  final double bufferSeconds;

  /// Current playback rate (1.0 = normal, 2.0 = 2x speed).
  final double playbackRate;

  /// Timestamp when this signal was generated.
  final DateTime timestamp;

  const DemandSignal({
    required this.level,
    required this.bufferSeconds,
    required this.playbackRate,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? const _ConstantDateTime();

  /// Recommended concurrency based on demand level.
  ///
  /// [baselineConcurrency] is the learned optimal concurrency for the device.
  /// [maxConcurrency] is the absolute maximum (e.g., device core limit).
  int recommendedConcurrency({
    required int baselineConcurrency,
    required int maxConcurrency,
  }) {
    return switch (level) {
      DemandLevel.coast => 1, // Minimum work
      DemandLevel.cruise => baselineConcurrency,
      DemandLevel.accelerate => (baselineConcurrency + 1).clamp(1, maxConcurrency),
      DemandLevel.emergency => maxConcurrency,
      DemandLevel.critical => maxConcurrency, // + priority boost handled separately
    };
  }

  /// Whether this signal should bypass normal cooldown periods.
  bool get bypassesCooldown =>
      level == DemandLevel.emergency || level == DemandLevel.critical;

  /// Whether priority boosting should be applied (immediate queue priority).
  bool get shouldBoostPriority => level == DemandLevel.critical;

  @override
  String toString() =>
      'DemandSignal($level, buffer: ${bufferSeconds.toStringAsFixed(1)}s, rate: ${playbackRate}x)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DemandSignal &&
          level == other.level &&
          bufferSeconds == other.bufferSeconds &&
          playbackRate == other.playbackRate;

  @override
  int get hashCode => Object.hash(level, bufferSeconds, playbackRate);
}

/// Constant DateTime for const constructor (replaced at runtime).
class _ConstantDateTime implements DateTime {
  const _ConstantDateTime();

  @override
  dynamic noSuchMethod(Invocation invocation) => DateTime.now();
}

/// Thresholds for determining demand level.
///
/// These are base thresholds at 1.0x playback speed.
/// At higher speeds, effective buffer is reduced (thresholds effectively increase).
class DemandThresholds {
  const DemandThresholds._();

  /// Buffer threshold for coast phase (seconds).
  static const double coastThreshold = 45.0;

  /// Buffer threshold for cruise phase (seconds).
  static const double cruiseThreshold = 30.0;

  /// Buffer threshold for accelerate phase (seconds).
  static const double accelerateThreshold = 15.0;

  /// Buffer threshold for emergency phase (seconds).
  static const double emergencyThreshold = 5.0;

  /// Calculate the demand level from buffer and playback rate.
  ///
  /// Buffer thresholds scale with playback rate:
  /// - At 2x speed, 30s of audio is consumed in 15s real time
  /// - So we need 2x the audio buffer to maintain the same real-time cushion
  static DemandLevel calculateLevel(double bufferSeconds, double playbackRate) {
    // Effective buffer = actual buffer / playback rate
    // At 2x speed, 60s buffer provides only 30s of real-time cushion
    final effectiveBuffer = bufferSeconds / playbackRate;

    if (effectiveBuffer < emergencyThreshold) return DemandLevel.critical;
    if (effectiveBuffer < accelerateThreshold) return DemandLevel.emergency;
    if (effectiveBuffer < cruiseThreshold) return DemandLevel.accelerate;
    if (effectiveBuffer < coastThreshold) return DemandLevel.cruise;
    return DemandLevel.coast;
  }
}
